#include "modbus.h"
#include "my_types.h"
//2015 05 04 by www.sh-xiaomo.com
//用来通Modbus协议控制MT系列运动控制卡

//可以应用于单片机、Mac、Linux、Windows等平台，无需开发包支持
//C51请定义下表为code
static const uint8 iTable_Hi[] = {
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 
    0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41, 
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x00, 0xC1, 0x81, 0x40,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40, 0x01, 0xC0, 0x80, 0x41, 0x01, 0xC0, 0x80, 0x41,
    0x00, 0xC1, 0x81, 0x40
};

static const uint8 iTable_Lo[] = {
    0x00, 0xC0, 0xC1, 0x01, 0xC3, 0x03, 0x02, 0xC2, 0xC6, 0x06, 0x07, 0xC7,
    0x05, 0xC5, 0xC4, 0x04, 0xCC, 0x0C, 0x0D, 0xCD, 0x0F, 0xCF, 0xCE, 0x0E,
    0x0A, 0xCA, 0xCB, 0x0B, 0xC9, 0x09, 0x08, 0xC8, 0xD8, 0x18, 0x19, 0xD9,
    0x1B, 0xDB, 0xDA, 0x1A, 0x1E, 0xDE, 0xDF, 0x1F, 0xDD, 0x1D, 0x1C, 0xDC,
    0x14, 0xD4, 0xD5, 0x15, 0xD7, 0x17, 0x16, 0xD6, 0xD2, 0x12, 0x13, 0xD3,
    0x11, 0xD1, 0xD0, 0x10, 0xF0, 0x30, 0x31, 0xF1, 0x33, 0xF3, 0xF2, 0x32,
    0x36, 0xF6, 0xF7, 0x37, 0xF5, 0x35, 0x34, 0xF4, 0x3C, 0xFC, 0xFD, 0x3D,
    0xFF, 0x3F, 0x3E, 0xFE, 0xFA, 0x3A, 0x3B, 0xFB, 0x39, 0xF9, 0xF8, 0x38, 
    0x28, 0xE8, 0xE9, 0x29, 0xEB, 0x2B, 0x2A, 0xEA, 0xEE, 0x2E, 0x2F, 0xEF,
    0x2D, 0xED, 0xEC, 0x2C, 0xE4, 0x24, 0x25, 0xE5, 0x27, 0xE7, 0xE6, 0x26,
    0x22, 0xE2, 0xE3, 0x23, 0xE1, 0x21, 0x20, 0xE0, 0xA0, 0x60, 0x61, 0xA1,
    0x63, 0xA3, 0xA2, 0x62, 0x66, 0xA6, 0xA7, 0x67, 0xA5, 0x65, 0x64, 0xA4,
    0x6C, 0xAC, 0xAD, 0x6D, 0xAF, 0x6F, 0x6E, 0xAE, 0xAA, 0x6A, 0x6B, 0xAB, 
    0x69, 0xA9, 0xA8, 0x68, 0x78, 0xB8, 0xB9, 0x79, 0xBB, 0x7B, 0x7A, 0xBA,
    0xBE, 0x7E, 0x7F, 0xBF, 0x7D, 0xBD, 0xBC, 0x7C, 0xB4, 0x74, 0x75, 0xB5,
    0x77, 0xB7, 0xB6, 0x76, 0x72, 0xB2, 0xB3, 0x73, 0xB1, 0x71, 0x70, 0xB0,
    0x50, 0x90, 0x91, 0x51, 0x93, 0x53, 0x52, 0x92, 0x96, 0x56, 0x57, 0x97,
    0x55, 0x95, 0x94, 0x54, 0x9C, 0x5C, 0x5D, 0x9D, 0x5F, 0x9F, 0x9E, 0x5E,
    0x5A, 0x9A, 0x9B, 0x5B, 0x99, 0x59, 0x58, 0x98, 0x88, 0x48, 0x49, 0x89,
    0x4B, 0x8B, 0x8A, 0x4A, 0x4E, 0x8E, 0x8F, 0x4F, 0x8D, 0x4D, 0x4C, 0x8C,
    0x44, 0x84, 0x85, 0x45, 0x87, 0x47, 0x46, 0x86, 0x82, 0x42, 0x43, 0x83,
    0x41, 0x81, 0x80, 0x40
};

//定义发送缓冲区
#define WRITE_MAX 13
#define READ_MAX  9
uint8 iWrite_Buffer[WRITE_MAX];//最多13字节
uint8 iWrite_Count;//写指针
uint8 iRead_Buffer[READ_MAX];//最多9字节
uint8 iRead_Count;//读指针
void USART_Send(u8 Data);
//请根据单片机串口的发送，改写本函数
//通过串口发送一个字节,可以中断发送，也可以查询发送
void UART_Write_One(uint8 AValue)
{
 // USART_Send(AValue);  //在其它处提供发送函数
}
//此函数发送指令帧，无需改写
void UART_Write(uint16 ACount)
{
  uint16 i;
  for(i=0;i<ACount;i++)
  {
    UART_Write_One(iWrite_Buffer[i]);  
  }
}

//请根据单片机串口的接收，改写本函数
//接收一个字节,一般在串口的接收中断中调用本函数，也可以修改为查询模式

//中断模式下请在中断处调用本函数
void Read_One(uint8 AValue)
{
   if(iRead_Count<READ_MAX)
   {
      iRead_Buffer[iRead_Count++]=AValue;
   }
}
//启动接收，无需改写
void Start_Read(void)
{
    uint16 i;
    iRead_Count=0;
    for(i=0;i<READ_MAX;i++)
    {
        iRead_Buffer[i]=0;
    }
}
    
//根据缓冲区和数据长度，计算校验和，此函数无需修改
uint16 Calc_CRC16(uint8 * iRead_Buffer, uint8 ALen)
{
    uint8           iHi = 0xFF;
    uint8           iLo = 0xFF;
    uint16          iIndex;
    uint16          i;
    for(i=0;i<ALen;i++)
    {
        iIndex = iLo ^ *( iRead_Buffer++ );
        iLo = ( uint8 )( iHi ^ iTable_Hi[iIndex] );
        iHi = iTable_Lo[iIndex];
    }
    return ( uint16 )( iHi << 8 | iLo );
}

//读指令的循环超时时间，根据单片机的速度更改，超时时间一般相当于为1S
//如果内部有时间计数，可以考虑用时间计数，请修改读写变量函数中的超时判断部分
#define TIME_OUT_MAX  1000000   
//写运动卡中对应的变量值,返回1成功，0失败
uint8 PLC_Set_Var_Data(uint16 AID,int32 AValue)
{
 uint16 AStart;
 int32_byte AValueByte;
 uint16 ACrc;
 uint16 bCheck;
 uint32 iCount;
 iWrite_Buffer[0]=1;//从机地址
 iWrite_Buffer[1]=16;//功能码
 AStart=AID*2;//每个变量为32位，modbus为16位变量,地址翻倍
 iWrite_Buffer[2]=AStart>>8;   //起始地址高
 iWrite_Buffer[3]=AStart & 0x00FF;   //起始地址低
 iWrite_Buffer[4]=0;
 iWrite_Buffer[5]=2;//写2个寄存器
 iWrite_Buffer[6]=4;//字节数
	
	//赋值拆成字节
 AValueByte.i32=AValue;
 //此处很重要，不同的平台和编译器编译出来的结果不一样	
 //将32位有符号数拆成4字节 低字高字节 + 低字低字节 +高字高字节+高字低字节
 //例如 0x01020304 顺序为 0x03 0x04 0x01 0x02
 //此为一般的顺序，请人工查看一下
 iWrite_Buffer[7]=AValueByte.bytes[1];
 iWrite_Buffer[8]=AValueByte.bytes[0];
 iWrite_Buffer[9]=AValueByte.bytes[3];
 iWrite_Buffer[10]=AValueByte.bytes[2]; 
 

 ACrc=Calc_CRC16(iWrite_Buffer,11);
 iWrite_Buffer[11]=ACrc & 0x00FF;    //低CRC
 iWrite_Buffer[12]=ACrc >> 8; //高CRC  此处为反，Modbus定义
 //准备接收数据
 Start_Read();
 //发送数据
 UART_Write(13);
 //读返回值
 iCount=0;
 while((iCount<TIME_OUT_MAX)&&(iRead_Count<8))
 {
   iCount++; 
 }
 if(iCount>=TIME_OUT_MAX)
 {
     return 0;
 }
 else
 {
   ACrc=Calc_CRC16(iRead_Buffer,6);  
   //判断数据格式
    bCheck=(1==iRead_Buffer[0])&&
    (16==iRead_Buffer[1])&&
    (iRead_Buffer[2]==(AStart >> 8))&&
    (iRead_Buffer[3]==(AStart & 0x00FF))&&
    (0==iRead_Buffer[4])&&
    (2==iRead_Buffer[5])&&
    (iRead_Buffer[6]== (ACrc & 0x00FF))&&
    (iRead_Buffer[7]==(ACrc >> 8));   
   if(bCheck) //如果编译器不支持，请直接将以上判断移入括号内
   {
    return 1; //写变量成功
   }
   else
   {
    return 0;
   }
 }   
}
uint8 PLC_Get_Var_Data(uint16 AID,int32* pValue)
{
 uint16 AStart;
 int32_byte AValueRead;
 uint16 ACrc;
 uint16 bCheck;
 uint32 iCount;
	
 iWrite_Buffer[0]=1;//从机地址
 iWrite_Buffer[1]=03;//功能码
 AStart=AID*2;//每个变量为32位，modbus为16位变量
 iWrite_Buffer[2]=AStart >> 8;   //起始地址高
 iWrite_Buffer[3]=AStart & 0x00FF;   //起始地址低
 iWrite_Buffer[4]=0;
 iWrite_Buffer[5]=2;//读2个寄存器

 ACrc=Calc_CRC16(iWrite_Buffer,6);
 iWrite_Buffer[6]=ACrc & 0x00FF;    //低CRC
 iWrite_Buffer[7]=ACrc >> 8; //高CRC

 //准备接收数据
 Start_Read();
 //发送数据
 UART_Write(8);
 //读返回值
 iCount=0;
 while((iCount<TIME_OUT_MAX)&&(iRead_Count<9))
 {
   iCount++; 
 }
 if(iCount>=TIME_OUT_MAX)
 {
     return 0;
 }
 else
 {
   ACrc=Calc_CRC16(iRead_Buffer,7); 
   bCheck=(1==iRead_Buffer[0])&&
    (3==iRead_Buffer[1])&&
    (4==iRead_Buffer[2])&& //返回4个字节
    (iRead_Buffer[7]== (ACrc & 0x00FF))&&
    (iRead_Buffer[8]==(ACrc >> 8));
	 if(bCheck)
	 {
 //此处很重要，不同的平台和编译器编译出来的结果不一样	
 //将4字节组合成32位有符号数， 低字高字节 + 低字低字节 +高字高字节+高字低字节
 //例如 0x01020304 顺序为 0x03 0x04 0x01 0x02
 //此为一般的顺序，请人工查看一下		 
		 AValueRead.bytes[1]=iRead_Buffer[3];
		 AValueRead.bytes[0]=iRead_Buffer[4];
		 AValueRead.bytes[3]=iRead_Buffer[5];
		 AValueRead.bytes[2]=iRead_Buffer[6];
		 *pValue=AValueRead.i32;
		 return 1;//读变量成功
	 }
	 else
	 {
		 return 0;
	 }
 }
}
